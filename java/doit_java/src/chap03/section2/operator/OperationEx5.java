// 비트 이동 연산자를 사용하여 연산하기
package chap03.section2.operator;

public class OperationEx5 {
    public static void main(String[] args) {

        int num = 0B00000101;           // 5를 8비트 2진수로 나타냄

        System.out.println(num << 2);   // 왼쪽으로 2비트 이동 00010100 (20)
        System.out.println(num >> 2);   // 오른쪽으로 2비트 이동 00000001 (1)
        System.out.println(num >>> 2);  // 오른쪽으로 2비트 이동 00000001 (1)

        System.out.println(num);        // num에 값을 대입하지 않았으므로 비트 이동과 관계없이 기존 값 그대로 출력

        num = num << 2;                 // 왼쪽으로 2비트 이동한 값을 다시 num에 대입
        System.out.println(num);
    }
}

/*

비트 논리 연산자

& (AND) 연산자
두 개의 비트 값이 모두 1인 경우 결과값 1

  num1: 0000 0101 ( 5)
& num2: 0000 1011 (11)
-----------------
result: 0000 0001 ( 1)

| (OR) 연산자
두 개의 비트 값이 하나라도 1이면 결과값 1

  num1: 0000 0101 (5)
| num2: 0000 1010 (10)
-----------------
result: 0000 1111 (15)

^ (XOR) 연산자
두 개의 비트 값이 같은 값이면 0, 다른 값이면 1

  num1: 0000 0101 ( 5)
^ num2: 0000 1110 (14)
-----------------
result: 0000 1011 (11)

~ (반전) 연산자
비트 값을 0은 1로, 1은 0으로 반전 시킴

  num : 0000 0101 ( 5)
-----------------
~ num : 1111 1010 (-11)


비트 논리 연산자 (시프트 연산자)

<< 연산자
왼쪽으로 비트를 이동, 기존값에 2ⁿ만큼 곱한것과 같다.

 num      : 0000 0101 ( 5)
---------------------
 num << 2 : 0001 0100 (20)

>> 연산자
오른쪽으로 비트를 이동, 기존값을 2ⁿ만큼 나눈것과 같다.

 num      : 0000 1010 (10)
---------------------
 num >> 2 : 0000 0010 ( 2)  =  10 / 2²

<<<, >>> 연산자
<<, >> 연산과 동일하게 비트를 오른쪽으로 이동시키지만 왼쪽에 채워지는 비트 값이
부호 비트와 상관없이 무조건 0이 된다.

 */

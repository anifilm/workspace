// Q6 3차원 메모리 동적 할당하기
// 다음과 같이 3차원 배열 문법으로 data 변수를 선언했습니다.
// char data[2][3][4];

// 배열의 차원 개념은 논리적 개념이라서 실제 메모리에 할당될 때는 오른쪽과 같이 1차원 배열과 동일하게 할당됩니다.
// 각 항목의 크기가 1바이트(char)이고 항목의 개수가 2 x 3 x 4 = 24 개 이기 때문에 data 변수는 총 24바이트의 메모리를
// 차지하게 됩니다.

// 3차원 포인터와 메모리 동적 할당을 이용해서도 같은 구조를 만들 수 있습니다. 물론 포인터를 사용하면 주소를 저장하기
// 위한 메모리가 추가되기 때문에 다음과 같은 형태를 띕니다. 그러면 3차원 포인터 (char ***p;)와 malloc 함수를 사용하여
// 위 그름과 같이 메모리를 할당하도록 코드를 구성해 보세요.

// (힌트) 프로그램이 종료되기 전에 free 함수를 사용하여 동적으로 할당된 메모리를 해제하는 코드까지 작성해야 합니다.
#include <stdio.h>

int main() {

    // *(p + 0) 와 *(p + 1) 에 해당하는 메모리 생성
    char p = (char ***)malloc(sizeof(char **) * 2);
    int i, j;

    for (i = 0; i < 2; i++) {
        // *((p + 0) + 0) 에서 *(*(p + 1) + 2) 에 해당하는 메모리 생성
        // *(p + 0) = (char **)malloc(sizeof(char *) * 3);
        // *(p + 1) = (char **)malloc(sizeof(char *) * 3);
        *(p + i) = (char **)malloc(sizeof(char *) * 3);

        for (j = 0; j < 3; j++) {
            // *(*(*(p + 0) + 0) + 0) 에서 *(*(*(p + 1) + 2) + 3) 까지에 해당하는 메모리 생성
            // *(*(p + 0) + 0) = (char *)malloc(sizeof(char) * 4);
            // *(*(p + 0) + 1) = (char *)malloc(sizeof(char) * 4);
            // *(*(p + 0) + 2) = (char *)malloc(sizeof(char) * 4);
            // *(*(p + 1) + 0) = (char *)malloc(sizeof(char) * 4);
            // *(*(p + 1) + 1) = (char *)malloc(sizeof(char) * 4);
            // *(*(p + 1) + 2) = (char *)malloc(sizeof(char) * 4);
            *(*(p + i) + j) = (char *)malloc(sizeof(char) * 4);
        }
    }

    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++) {
            // *(*(*(p + 0) + 0) + 0) 에서 *(*(*(p + 1) + 2) + 3) 까지에 해당하는 메모리 해제
            // free(*(*(p + 0) + 0));
            // free(*(*(p + 0) + 1));
            // free(*(*(p + 0) + 2));
            // free(*(*(p + 1) + 0));
            // free(*(*(p + 1) + 1));
            // free(*(*(p + 1) + 2));
            free(*(*(p + i) + j));
        }
        // *((p + 0) + 0) 에서 *(*(p + 1) + 2) 에 해당하는 메모리 해제
        // free(*(p + 0));
        // free(*(p + 1));
        free(*(p + i));
    }
    // *(p + 0) 와 *(p + 1) 에 해당하는 메모리 해제
    free(p);

    return 0;
}

// 파일로부터 데이터를 읽어 봅시다.
#include <stdio.h>

int main() {

    int ch, i;
    FILE* fp = fopen("24-1_1_data.txt", "rt");    // 읽기 모드로 파일 스트림 (입력)을 생성
    if (fp == NULL) {
        puts("파일열기 실패!");
        return -1;
    }

    for (i = 0; i < 3; i++) {
        ch = fgetc(fp); // 파일 포인터에서 문자 하나 가져오기
        printf("%c\n", ch);
    }

    fclose(fp);
    puts("\n파일 읽기를 완료하였습니다.");

    return 0;
}

/*

Chapter 21에서 호출한 적 있는 fflush() 함수

int fflush(FILE* stream);
    -> 함수호출 성공 시 0, 실패 시 EOF 반환

  - 출력 버퍼를 비운다는 것은 출력 버퍼에 저장된 데이터를 목적지로 전송한다는 의미
  - 입력 버퍼를 비운다는 것은 입력 버퍼에 저장된 데이터를 소멸시킨다는 의미
  - fflush 함수는 출력 버퍼를 비우는 함수이다.
  - fflush 함수는 입력 버퍼를 대상으로 호출하는 것을 권장하지 않는다. fflush(stdin);

위의 내용은 파일 스트림에도 그대로 적용이 된다. 즉 다음과 같이 파일의 출력 버퍼를
비울 수 있다. 그러면 출력 버퍼에 저장된 데이터가 실제로 파일에 저장된다.
  int main(void) {
      FILE* fp = fopen("data.txt", "wt");   // 쓰기모드로 파일 스트림 (출력) 생성
      ...
      fflush(fp);   // 출력 버퍼를 비우라는 요청 (데이터 파일에 저장)
      ...
  }


fflush() 함수의 올바른 사용법 (feat. getchar())

보통 scanf, fgets 등의 입력 함수를 이용해 데이터를 입력받고난 후 다음 데이터를 입력
받기 전에 버퍼에 남아 있는 데이터를 지우기 위해 fflush(stdin); 코드를 적어서 입력
버퍼의 내용을 지우는데 많이 사용됩니다. 그러나 fflush(stdin);과 같이 사용하는것은
잘못된 방법이며 위험한 방법입니다.

fflush() 함수는 함수의 인자에 해당하는 출력버퍼를 비우는 역할을 합니다. 따라서
fflush(stdin); 과 같이 입력버퍼를 fflush()의 인자로 전달할수 없습니다. 예외적으로
Visual Studio에서는 이 방법을 허용하고 있지만 다른 컴파일러에서는 사용할 수 없고,
입력버퍼가 비워진다 할지라도 그 결과를 예측할 수 없습니다. 그러므로 fflush() 함수는
fflush(stdout); 처럼 출력버퍼를 비우는 용도로만 사용해야 하지 fflush(stdin); 처럼
입력버퍼를 인자로 전달하는 형태로 사용해선 절대 안됩니다. 참고로 fflush() 가 출력
버퍼를 비운다는 뜻은 버퍼에 있는 데이터를 그냥 지워버리는것이 아니라 버퍼에 있는
데이터를 파일이나, 모니터 등 출력하고자 하는 목적지로 전송하는것을 뜻합니다.
  (중략...)

이와 같은 현상을 방지하기 위해서는 다음 입력을 받기 전에 버퍼에 있는 값들을 미리 읽어서
버퍼를 비워놔야 합니다. 간단하게 getchar() 함수를 사용할 수 있습니다.
getchar() 함수는 버퍼에서 문자 하나를 읽어서 반환하는 함수입니다. 문자 하나만 읽어오기
때문에 다음과 같이 반복문의 형태로 사용하는게 좋습니다.
  while (getchar() != '\n');

버퍼에서 엔터(\n)를 읽을때 까지 데이터를 읽어옵니다. 물론 데이터를 읽어와서 반환하기는
하지만 이 값을 어디에도 저장하고 있지 않으므로 순수하게 버퍼를 비우는 역할을 하는 코드
입니다.


출처: https://forarchitect.tistory.com/79

*/

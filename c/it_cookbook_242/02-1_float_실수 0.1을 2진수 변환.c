#include <stdio.h>

int main() {

    int i;
    float sum = 0.0f;

    for (i = 0; i < 100; i++)
        sum = sum + 0.1f;

    printf("The sum is %f\n", sum);

	return 0;
}

/*

부동 소수 연산에는 항상 오차가 개입 될수 있다는 점에 유의해야 한다.
예는 0.1을 100번 더한 값을 출력하는 프로그램이다.
이 프로그램을 샐행한 결과는 10.000000이 아니라 10.000002 이다.
부동 소수 표현에 오차가 있기 때문이다.
0.1을 2진수로 표현해 보면 그 이유를 알 수 있다.


[실수 0.1을 2진수로 변환하고 float type으로 저장되는 과정]

정수 부분 0: 0
소 부분 0.1: 2진수로 변환

0.1 * 2 = 0.2 (0)
0.2 * 2 = 0.4 (0)
0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.4 (0)
0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.4 (0)

0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.8 (0)

0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.8 (0)

0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.8 (0)

0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.8 (0)

0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.8 (0)

0.4 * 2 = 0.8 (0)
0.8 * 2 = 1.6 (1)
0.6 * 2 = 1.2 (1)
0.2 * 2 = 0.8 (0)

.
.
.

0.0001 1001 1001 1001 1001 1001 1001 ...

위와 같은 값을 얻었다. 위 표현을 부동 소수 형태로 변경하면

1.1001 1001 1001 1001 1001 1001 1001 ... * 2^ -4

가수부는 23bit만 저장할 수 있다. 따라서 무한 반복되는 값을 사용할 수 없다.
부동 소수 형태에서 소수점 24자리에서 반볼림 하게 된다.

이따, 0.1은 내부적으로 0.1보다 큰 값으로 저장되게 된다.

이로 인해 구조적인 오차 문제가 발생하게 된다.

부호 1bit: 0
지수 8bit: -4 + 127 = 123 -> 0111 1011
가수 23bit: 1001 1001 1001 1001 1001 101

결국, 0.1은 다음과 같은 float type으로 저장된다.

0 0111 1011 1001 1001 1001 1001 1001 101


[오차 없이 실수를 사용하고 싶다면]

1. float 의 가수 정밀도는 6~7자리
2. double의 가수 정밀도는 15~16자리 이다


(출처) https://karmainearth.tistory.com/143

*/
